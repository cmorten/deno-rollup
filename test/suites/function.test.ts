// deno-lint-ignore-file no-explicit-any

/**
 * Code adapted from https://github.com/rollup/rollup/blob/master/test/function/index.js
 */

import { ensureUrl } from "../../src/rollup-plugin-deno-resolver/ensureUrl.ts";
import { basename } from "../../deps.ts";
import { rollup } from "../../mod.ts";
import { runTestSuiteWithSamples } from "../utils.ts";
import { compareError } from "../compareError.ts";
import { it } from "../mod.ts";

function isSpecialInput(config: any) {
  return config?.description === "does not mangle input";
}

await runTestSuiteWithSamples(
  "function",
  [
    // TODO: bring all excluded tests into this library to run on local fs.
    // These require `fs.readFileSync` which cannot mock for remote files.
    "custom-loaders",
    "custom-path-resolver-on-entry",
    "export-default-anonymous-function",
    // These require module resolution which cannot mock for remote files (CWD can't be mocked for the remote directory)
    // or assume that we are local for output / error assertions (which would fail because we are now passing urls).
    "custom-resolve-options",
    "chunk-filename-not-available-renderStart",
    "file-references-in-bundle",
    "no-input",
    "set-asset-source-chunk",
    "dependant-dynamic-import-no-effects",
    "dependant-dynamic-import-not-included",
    "dependant-not-part-of-graph",
    "external-dependant",
    "missing-dependant",
    "custom-path-resolver-async",
    "custom-path-resolver-sync",
    "options-async-hook",
    "options-hook",
    "preserve-symlink",
    "resolve-relative-external-id",
    "symlink",
    "transform-without-code",
    // This fails because we don't support sourcemaps for URL imports, so in removing them
    // the transform source function is never called, so can't assert that it is invalid.
    "invalid-transform-source-function",
    // This fails due to strict checks on the array generated by this.getModuleIds() and
    // we're seeing a different order. Could be runtime related?
    "plugin-module-information",
    // TODO: fix the sample as it hangs, not obvious why shouldn't work as a remote import.
    "empty-string-as-module-name",
    // Not supporting deprecated functionality.
    "deprecated",
    "deprecations",
  ],
  (dir: string, config: any) => {
    it(`${basename(dir)}: ${config?.description}`, async () => {
      (globalThis as any).__dirname = dir;

      if (config.show) {
        console.group(basename(dir));
      }
      if (config.before) {
        config.before();
      }

      const configInput = config?.options?.input;

      if (configInput && !isSpecialInput(config)) {
        if (Array.isArray(configInput)) {
          config.options.input = configInput.map((input) =>
            new URL(input, dir).href
          );
        } else if (typeof configInput === "object") {
          config.options.input = Object.fromEntries(
            Object.entries(config.options.input as Record<string, string>).map((
              [alias, input],
            ) => [alias, new URL(input, dir).href]),
          );
        } else {
          config.options.input = new URL(configInput, dir).href;
        }
      }

      const inputOptions = {
        input: ensureUrl(`${dir}main.js`),
        strictDeprecations: true,
        onwarn: () => {},
        ...config?.options,
      };

      return await rollup(inputOptions)
        .then((bundle) => {
          if (config.error) {
            throw new Error("Expected an error while rolling up");
          }

          let unintendedError: Error;
          let result: any[];

          if (config?.options?.output?.manualChunks) {
            config.options.output.manualChunks = Object.fromEntries(
              Object.entries(
                config.options.output.manualChunks as Record<string, string[]>,
              )
                .map((
                  [alias, inputs],
                ) => [alias, inputs.map((input) => new URL(input, dir).href)]),
            );
          }

          const outputOptions = {
            exports: "auto",
            format: "cjs",
            ...config?.options?.output,
          };

          return bundle.generate(outputOptions).then(({ output }) => {
            if (config.generateError) {
              unintendedError = new Error(
                "Expected an error while generating output",
              );
            }

            result = output;
          }).catch((err) => {
            if (config.generateError) {
              compareError(err, config.generateError);
            } else {
              throw err;
            }
          }).then(() => {
            if (unintendedError) {
              throw unintendedError;
            }

            if (config.error || config.generateError) {
              return;
            }

            const codeMap = result.reduce((codeMap, chunk) => {
              codeMap[chunk.fileName] = chunk.code;
              return codeMap;
            }, {});

            if (config.code) {
              config.code(result.length === 1 ? result[0].code : codeMap);
            }

            const entryId = result.length === 1
              ? result[0].fileName
              : "main.js";

            // A limitation of dealing with remote URL it is that it is not considered
            // an absolute path by rollup code, therfore the module will be cast as virtual.
            // In an attempt to re-use as many remote test cases as possible, we are
            // accepting virtual prefixes here as acceptable.
            if (
              !codeMap.hasOwnProperty(entryId) &&
              !codeMap.hasOwnProperty(`_virtual/${entryId}`)
            ) {
              throw new Error(
                `Could not find entry "${entryId}" in generated output.\nChunks:\n${
                  Object.keys(
                    codeMap,
                  ).join("\n")
                }`,
              );
            }

            // TODO: check the following:
            //
            // - runtime errors
            // - exports
            // - bundle
            // - warnings
            // - old tests ran in after() hook

            return Promise.resolve()
              .then(() => {
                if (config.show || unintendedError) {
                  for (const chunk of result) {
                    console.group(chunk.fileName);
                    console.log(chunk.code);
                    console.groupEnd();
                    console.log();
                  }
                }

                if (config.show) {
                  console.groupEnd();
                }
                if (unintendedError) {
                  throw unintendedError;
                }
              });
          });
        }).catch((err) => {
          if (config.error) {
            compareError(err, config.error);
          } else {
            throw err;
          }
        });
    }, { sanitizeOps: false, sanitizeResources: false }); // TODO: we should not allow leaking ops and resources. May be some of the samples fire and forget promises?
  },
);
